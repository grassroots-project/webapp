import React, { Component } from 'react';
import { injectIntl } from 'react-intl'
import { Container } from 'reactstrap';

import SectionHeader from '../components/SectionHeader';

import Footer from '../components/Footer';
import Main from '../components/Main'
import Header from '../components/Header';


class Knowledge extends Component {
  componentDidMount() {
  }
  componentWillMount() {
  }
  render() {
    // const intl = this.props.intl

    return (
      <div>
        <Header />
        {/* <SectionHeader>
          <h2>Fund-Project</h2>
          <hr/>
          <p>我们希望可以在下面的问答中让您可以对我们有一个初步的了解</p>
          <p>如你所想，投资人对基金的运作方式有很多疑问。努力回答这些问题，这是更深入的技术。</p>
        </SectionHeader> */}
        <section>
          <Container className=''>
            {/* <h1 id="open-fund">Open Fund</h1>
        <p>虽然在最近一篇博客文章中描述CoinAlpha的长期愿景，但我提到我们的第一个产品是全球第一个符合美国证券法律和法规的区块链原生对冲基金。</p>
        <p>如你所想，读者对基金的运作方式有很多疑问。努力回答这些问题，这是更深入的技术。</p> */}
            <h2>为什么要使用区块链</h2>
            <p>因为区块链简化支付和信息流，不需要中介机构。</p>
            <p>与所有金融证券一样，基金是支配资本流动的市场参与者之间的法律契约，为了确保传统基金运作中资本流动的及时性、准确性，每个基金参与者或保持冗余系统和孤立的数据库，又或他们所依赖的其他中介机构如基金管理公司，会计师和审计师都会这样做。通过提供一个单一来源的真相，区块链智能合同使资金更高效、透明、流动性更强。</p>
            <h2 id="-">什么是智能合约</h2>
            <p>为了解释这是如何运作的，我们首先得定义智能合同的概念。智能合同是一种制定虚拟货币交易规则的微型计算机程序。打个比方，一个简单的智能合同就是一个由多个政党共同拥有的多功能钱包。对于双方共同拥有的钱包而言，任何对外转账都必须经过双方的签署授权。而由于智能合同建立在区块链上，它可以不需要通过第三公正方就可以制定和执行这些规则。</p>
            <p>正确地设定这些规则是至关重要的。一旦设定错误，后果不堪设想。</p>
            <p>“智能合同”原本是一个伟大的营销术语，但目前来看，市场上的智能合同既不智能，也算不上合同。事实上，一个更精确地描述智能合同当前功能的术语是 DUMB PROGRAM。</p>
            <p>DUMB PROGRAS 仍然非常有用：对于许多金融服务应用来说，将计算机程序的逻辑和数据与分布式分类技术的透明性和信任相结合，才是一场真正的变革。区块连中的智能合同以公开、公正、公平的方式执行，防止欺诈、错误交易，并且提供不变、可重复的审计跟踪，而不像许多参与者将语言转化成跨多个封闭系统的代码，也不需要相互协调的冗余数据结构。</p>
            <h2 id="-">基于区块链的基金怎么运作</h2>
            <p>为了履行传统基金管理人，托管人，付款银行，会计师和审计师的角色，CoinAlpha创建了一套开源智能合约，我们称之为基金协议：</p>
            <ul>
              <li>处理资金流入和流出：强制执行投资限制和处理申购和赎回；</li>
              <li>计算净资产价值：每天检索投资组合的总资产价值，在投资者和管理费用之间分配收益和损失，维持高水位；</li>
              <li>维护报告数据：将性能监控、税务、审计数据记录到以太坊区块链。</li>
            </ul>
            <h2 id="-ico-">基于区块链的基金如何与ICO相比</h2>
            <p>和 ICO 类似，我们的基金是在以太坊区块连中的智能合同，允许投资者通过以太币以换取基金发行的代币。我们基金的投资过程于 ICO 也类似：投资者按预设规则，把以太币转化为智能合同中的应付函数。</p>
            <p>然而，与 ICO 所不同的是，ICO 的投资收益可用于不确定价值的项目，区块链基金的投资收益只能投资在一个有限的流动性强的虚拟货币组合，并且每天在市场上标注。投资者收到的基金代笔直接表示在基金资产属于每个投资者的持股比例。虽然根据证券法规定，投资者不能将基金代币相互转让，但是每天可以进行赎回或追加认购。</p>
            <h2 id="-dao-">这是一个分散的自制组织（DAO）吗？</h2>
            <p>不需要。我们基金的投资需要对基金经理高度信任。</p>
            <p>这是因为我们的基金投资者希望他们的资本由集中的专业经理人管理，而不是通过分散的共识进行管理。</p>
            <h2 id="-">投资后投资者收益会发生什么？</h2>
            <p>一旦投资份额分配完毕，智能合同会立即生效，将资金分配到投资者在授权批准的交易所比如 GDAX 或者 GEMINI，CoinAlpha 公司注册的账户中。基金经理有权在这个帐户上交易并采用专有策略积极管理投资组合。</p>
            <p>我们热切期望分散交易的演变扩散，就像 radarrelay，etherdelta，paradex 从而减少我们对于集中交易依赖度。然而，就目前的日均成交量不到 5000 美元这点来看，分散交易并不是一个切实可行的选择。</p>
            <h2 id="-">基金如何处理区块链相关的挑战，如可扩展性和交易成本？</h2>
            <p>与其他部分，比如付款相比，基金管理系统是缓慢而昂贵的。对冲基金通常允许每月一次新的认购和赎回，每月运营成本通常是 50–100K 美元。相比而言，以区块链为基础的解决方案，效率明显提高。例如，执行每日资产净值（NAV）的计算，在新的每日资产净值中处理申购和赎回，并在以太坊区块链中公布所有交易的永久性记录，将仅仅耗时 2 分钟，花费 3 美元。</p>
            <h2 id="-">基金如何符合证券法？</h2>
            <p>与许多其他对冲基金一样，我们的基金遵照《1933 证券法》和《1940 投资公司法》的免税条款，来遵守相关法律法规。这意味着我们的基金只限于 99 名合格的投资者，只有美国本土纳税居民投资者可以投资，并且投资者不能将他们的代币转让给其他投资者。虽然我们的目标在达到一定的要求时，可以适当放松一些限制，但我们的首要任务是合法合规。此外，我们还与我们的律师合作，确保《智能合同》中包含的基金逻辑严格合法合规，反之亦然。</p>
            <h2 id="-">你如何处理安全和其他操作问题？</h2>
            <p>运行一个可能存在10年或更长时间的基金的智能合约需要与一次性ICO合同不同的设计：</p>
            <ul>
              <li>安全：我们只向外部投资者披露选定的职能。管理功能（如NAV计算）只能从存储在我们安全存储的气密硬件钱包中的地址中调用。</li>
              <li>可升级性：我们委托与处理资金流相关的逻辑，并将净资产值计算到可能升级以解决安全漏洞并修复错误的子合同。</li>
              <li>模块化：每日计算依赖于由离线数据源提供的数据。封装与这些数据源的交互的模块需要灵活，可热插拔并且在数据源不可用或需要调整的情况下具有弹性。</li>
              <li>合规：与其让所有人都可以开放基金，我们的合同使得经理人工批准每一位新的投资者，因为基金仅限于99位合格的客户。非白名单投资者无法将Ether汇入基金。</li>
            </ul>
            <h2 id="-">我想深入代码！</h2>
            <p>为了通过透明度和增加信任，我们将开源了用于我们基金的智能合约（Github repo）。另外，我们创建了一个wiki，提供了技术架构的概述。</p>
          </Container>
        </section>

        <Footer />
      </div>
    );
  }
}

export default injectIntl(Knowledge);
